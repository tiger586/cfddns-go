package service

import (
	"cfddns/cloudflare"
	"cfddns/config"
	"cfddns/webhook"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type DDNSService struct {
	config    *config.Config
	cfClient  *cloudflare.CloudflareClient
	webhook   *webhook.WebhookClient
	currentIP string            // ç•¶å‰çš„å…¬å…± IP
	dnsIPs    map[string]string // è¨˜éŒ„åç¨± -> DNS è¨˜éŒ„ä¸­çš„ IP
	stopChan  chan bool
	lastCheck time.Time
	nextCheck time.Time
}

var verbose bool

func NewDDNSService(cfg *config.Config) *DDNSService {
	cfClient := cloudflare.NewClient(&cfg.Cloudflare)

	webhookClient := webhook.NewClient(
		cfg.Webhook.URL,
		cfg.Webhook.ChatID,
		cfg.Webhook.Type,
		cfg.Webhook.Template,
		cfg.Webhook.Enabled,
		cfg.Webhook.OnSuccess,
		cfg.Webhook.OnFailure,
	)

	now := time.Now()
	return &DDNSService{
		config:    cfg,
		cfClient:  cfClient,
		webhook:   webhookClient,
		dnsIPs:    make(map[string]string),
		stopChan:  make(chan bool),
		lastCheck: now,
		nextCheck: now.Add(time.Duration(cfg.Global.CheckInterval) * time.Second),
	}
}

func SetVerbose(v bool) {
	verbose = v
}

func (d *DDNSService) GetCurrentIP() (string, error) {
	var lastErr error

	if verbose {
		fmt.Printf("ğŸ” æ­£åœ¨æª¢æŸ¥å…¬å…± IP...\n")
	}

	for i, url := range d.config.Global.IPCheckURLs {
		if verbose {
			fmt.Printf("   å˜—è©¦æœå‹™ %d: %s\n", i+1, url)
		}

		resp, err := http.Get(url)
		if err != nil {
			lastErr = fmt.Errorf("æœå‹™ %s å¤±æ•—: %w", url, err)
			if verbose {
				fmt.Printf("   âŒ %v\n", lastErr)
			}
			continue
		}
		defer resp.Body.Close()

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			lastErr = fmt.Errorf("è®€å–éŸ¿æ‡‰å¤±æ•—: %w", err)
			if verbose {
				fmt.Printf("   âŒ %v\n", lastErr)
			}
			continue
		}

		ip := strings.TrimSpace(string(body))
		if isValidIP(ip) {
			if verbose {
				fmt.Printf("   âœ… å¾ %s ç²å–åˆ°æœ‰æ•ˆ IP: %s\n", url, ip)
			}
			return ip, nil
		}

		lastErr = fmt.Errorf("å¾ %s ç²å–çš„ IP ç„¡æ•ˆ: %s", url, ip)
		if verbose {
			fmt.Printf("   âŒ %v\n", lastErr)
		}
	}

	return "", fmt.Errorf("æ‰€æœ‰ IP æª¢æŸ¥æœå‹™éƒ½å¤±æ•—: %w", lastErr)
}

// æª¢æŸ¥ IP åœ°å€æ˜¯å¦æœ‰æ•ˆ
func isValidIP(ip string) bool {
	if ip == "" {
		return false
	}

	// ç°¡å–®çš„ IPv4 é©—è­‰
	parts := strings.Split(ip, ".")
	if len(parts) != 4 {
		return false
	}

	for _, part := range parts {
		if len(part) == 0 || len(part) > 3 {
			return false
		}

		// æª¢æŸ¥æ˜¯å¦ç‚ºæ•¸å­—
		for _, char := range part {
			if char < '0' || char > '9' {
				return false
			}
		}

		// æª¢æŸ¥æ•¸å­—ç¯„åœ
		num, err := strconv.Atoi(part)
		if err != nil || num < 0 || num > 255 {
			return false
		}

		// æª¢æŸ¥å‰å°é›¶ï¼ˆä½†å…è¨± "0"ï¼‰
		if len(part) > 1 && part[0] == '0' {
			return false
		}
	}

	return true
}

func (d *DDNSService) UpdateDNSRecords() error {
	now := time.Now()
	d.lastCheck = now
	d.nextCheck = now.Add(time.Duration(d.config.Global.CheckInterval) * time.Second)

	currentIP, err := d.GetCurrentIP()
	if err != nil {
		return fmt.Errorf("ç²å–ç•¶å‰ IP å¤±æ•—: %w", err)
	}

	// æª¢æŸ¥ IP æ˜¯å¦ç™¼ç”Ÿè®ŠåŒ–
	ipChanged := d.currentIP != currentIP
	if ipChanged {
		fmt.Printf("ğŸŒ æª¢æ¸¬åˆ° IP è®ŠåŒ–: %s â†’ %s\n", d.currentIP, currentIP)
		d.currentIP = currentIP
	} else if verbose {
		fmt.Printf("ğŸ’¤ å…¬å…± IP æœªè®ŠåŒ–: %s\n", currentIP)
	}

	// æ›´æ–°æ‰€æœ‰ DNS è¨˜éŒ„
	successCount := 0
	failureCount := 0
	updatedCount := 0

	for _, record := range d.config.DNSRecords {
		updated, err := d.updateSingleRecord(&record, currentIP)
		if err != nil {
			failureCount++
			fmt.Printf("âŒ æ›´æ–°è¨˜éŒ„ %s å¤±æ•—: %v\n", record.Name, err)
		} else {
			successCount++
			if updated {
				updatedCount++
			}
		}
	}

	// é¡¯ç¤ºæª¢æŸ¥çµæœå’Œä¸‹æ¬¡æª¢æŸ¥æ™‚é–“
	d.printCheckResult(updatedCount, failureCount)

	if failureCount > 0 {
		return fmt.Errorf("éƒ¨åˆ†è¨˜éŒ„æ›´æ–°å¤±æ•—: %d æˆåŠŸ, %d å¤±æ•—", successCount, failureCount)
	}

	return nil
}

// é¡¯ç¤ºæª¢æŸ¥çµæœå’Œä¸‹æ¬¡æª¢æŸ¥æ™‚é–“
func (d *DDNSService) printCheckResult(updatedCount, failureCount int) {
	now := time.Now()

	// é¡¯ç¤ºåŸºæœ¬çµæœ
	if updatedCount > 0 {
		fmt.Printf("âœ… æª¢æŸ¥å®Œæˆ: %d å€‹è¨˜éŒ„å·²æ›´æ–°", updatedCount)
	} else if failureCount > 0 {
		fmt.Printf("âš ï¸ æª¢æŸ¥å®Œæˆ: %d å€‹è¨˜éŒ„æ›´æ–°å¤±æ•—", failureCount)
	} else {
		fmt.Printf("âœ… æª¢æŸ¥å®Œæˆ: æ‰€æœ‰è¨˜éŒ„å·²åŒæ­¥")
	}

	// é¡¯ç¤ºä¸‹æ¬¡æª¢æŸ¥æ™‚é–“
	timeUntilNext := d.nextCheck.Sub(now)
	if timeUntilNext > 0 {
		fmt.Printf(" | ä¸‹æ¬¡æª¢æŸ¥: %s (%.0fç§’å¾Œ)\n",
			d.nextCheck.Format("15:04:05"),
			timeUntilNext.Seconds())
	} else {
		fmt.Printf(" | ä¸‹æ¬¡æª¢æŸ¥: %s\n", d.nextCheck.Format("15:04:05"))
	}
}

func (d *DDNSService) updateSingleRecord(record *config.DNSRecord, newIP string) (bool, error) {
	// ç²å–è¨˜éŒ„ç•¶å‰çš„ DNS IP
	currentDNSIP, err := d.cfClient.GetDNSRecordIP(record.Name, record.Type)
	if err != nil {
		errorMsg := fmt.Sprintf("ç²å–ç•¶å‰ DNS IP å¤±æ•—: %v", err)
		d.webhook.SendFailure(record.Name, errorMsg)
		return false, fmt.Errorf("ç²å–è¨˜éŒ„ %s çš„ç•¶å‰ IP å¤±æ•—: %w", record.Name, err)
	}

	// æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
	if currentDNSIP == newIP {
		if verbose {
			fmt.Printf("âœ… è¨˜éŒ„ %s å·²æ˜¯æœ€æ–° IP: %s\n", record.Name, newIP)
		}
		d.dnsIPs[record.Name] = newIP
		return false, nil // å·²ç¶“æ˜¯æœ€æ–° IPï¼Œä¸éœ€è¦æ›´æ–°
	}

	// éš»æœ‰ç•¶ IP è®ŠåŒ–æˆ– DNS ä¸åŒæ­¥æ™‚æ‰æ›´æ–°
	fmt.Printf("ğŸ”„ æ›´æ–°è¨˜éŒ„ %s: %s â†’ %s\n", record.Name, currentDNSIP, newIP)

	// ç²å–è¨˜éŒ„ ID
	recordID, err := d.cfClient.GetDNSRecordID(record.Name, record.Type)
	if err != nil {
		errorMsg := fmt.Sprintf("ç²å–è¨˜éŒ„ ID å¤±æ•—: %v", err)
		d.webhook.SendFailure(record.Name, errorMsg)
		return false, fmt.Errorf("ç²å–è¨˜éŒ„ ID å¤±æ•— (%s): %w", record.Name, err)
	}

	// æ›´æ–°è¨˜éŒ„
	if err := d.cfClient.UpdateDNSRecord(recordID, record, newIP); err != nil {
		errorMsg := fmt.Sprintf("æ›´æ–°è¨˜éŒ„å¤±æ•—: %v", err)
		d.webhook.SendFailure(record.Name, errorMsg)
		return false, fmt.Errorf("æ›´æ–° DNS è¨˜éŒ„å¤±æ•— (%s): %w", record.Name, err)
	}

	// æ›´æ–°åœ¨åœ°ç·©å­˜
	d.dnsIPs[record.Name] = newIP
	d.webhook.SendSuccess(currentDNSIP, newIP, record.Name)
	fmt.Printf("âœ… æˆåŠŸæ›´æ–°è¨˜éŒ„ %s â†’ %s\n", record.Name, newIP)

	return true, nil
}

func (d *DDNSService) Start() error {
	ticker := time.NewTicker(time.Duration(d.config.Global.CheckInterval) * time.Second)
	defer ticker.Stop()

	fmt.Println("ğŸš€ å•Ÿå‹• Cloudflare DDNS æœå‹™...")
	fmt.Printf("â° æª¢æŸ¥é–“éš”: %d ç§’\n", d.config.Global.CheckInterval)
	fmt.Printf("ğŸ“Š ç›£æ§è¨˜éŒ„æ•¸: %d\n", len(d.config.DNSRecords))
	fmt.Printf("ğŸŒ IP æª¢æŸ¥æœå‹™: %d å€‹\n", len(d.config.Global.IPCheckURLs))

	// åˆå§‹åŒ–ç•¶å‰ IP
	fmt.Println("\nğŸ” åˆå§‹åŒ–æª¢æŸ¥...")
	initialIP, err := d.GetCurrentIP()
	if err != nil {
		fmt.Printf("âŒ åˆå§‹ IP ç²å–å¤±æ•—: %v\n", err)
		// ä¸ç«‹å³é€€å‡ºï¼Œç¹¼çºŒå˜—è©¦
	} else {
		d.currentIP = initialIP
		fmt.Printf("âœ… ç•¶å‰å…¬å…± IP: %s\n", initialIP)
	}

	// åˆå§‹åŒ– DNS è¨˜éŒ„ IP ç·©å­˜
	fmt.Println("\nğŸ“‹ åˆå§‹åŒ– DNS è¨˜éŒ„ç‹€æ…‹...")
	for _, record := range d.config.DNSRecords {
		dnsIP, err := d.cfClient.GetDNSRecordIP(record.Name, record.Type)
		if err != nil {
			fmt.Printf("âš ï¸ ç²å–è¨˜éŒ„ %s çš„ç•¶å‰ IP å¤±æ•—: %v\n", record.Name, err)
			d.dnsIPs[record.Name] = "æœªçŸ¥"
		} else {
			d.dnsIPs[record.Name] = dnsIP
			status := "âœ… åŒæ­¥"
			if d.currentIP != "" && dnsIP != d.currentIP {
				status = "âš ï¸ ä¸åŒæ­¥"
			}
			fmt.Printf("   %s: %s - %s\n", record.Name, dnsIP, status)
		}
	}

	// ç«‹å³åŸ·è¡Œä¸€æ¬¡æª¢æŸ¥
	fmt.Println("\nğŸ”§ åŸ·è¡Œåˆå§‹æª¢æŸ¥...")
	if err := d.UpdateDNSRecords(); err != nil {
		fmt.Printf("âŒ åˆå§‹æª¢æŸ¥å¤±æ•—: %v\n", err)
	} else {
		fmt.Printf("âœ… åˆå§‹æª¢æŸ¥å®Œæˆ\n")
	}

	fmt.Printf("\nğŸ¯ æœå‹™å•Ÿå‹•å®Œæˆï¼Œé–‹å§‹ç›£æ§...\n")

	checkCounter := 1

	for {
		select {
		case <-ticker.C:
			checkCounter++

			if verbose {
				fmt.Printf("\n--- ç¬¬ %d æ¬¡æª¢æŸ¥ (%s) ---\n",
					checkCounter, time.Now().Format("15:04:05"))
			} else {
				fmt.Printf("\n[%s] ", time.Now().Format("15:04:05"))
			}

			// æª¢æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦è®Šæ›´
			if changed, err := d.config.HasChanged(); err == nil && changed {
				fmt.Println("ğŸ“ æª¢æ¸¬åˆ°é…ç½®æ–‡ä»¶è®Šæ›´ï¼Œé‡æ–°åŠ è¼‰...")
				if err := d.config.Reload(); err != nil {
					fmt.Printf("âŒ é‡æ–°åŠ è¼‰é…ç½®æ–‡ä»¶å¤±æ•—: %v\n", err)
				} else {
					// d.webhook = webhook.NewClient(
					// 	d.config.Webhook.URL,
					// 	d.config.Webhook.ChatID,
					// 	d.config.Webhook.Type,
					// 	d.config.Webhook.Template,
					// 	d.config.Webhook.Enabled,
					// 	d.config.Webhook.OnSuccess,
					// 	d.config.Webhook.OnFailure,
					// )
					// d.webhook.SendInfo("é…ç½®æ–‡ä»¶å·²é‡æ–°åŠ è¼‰")
					fmt.Printf("âœ… é…ç½®æ–‡ä»¶é‡æ–°åŠ è¼‰å®Œæˆ\n")
				}
			}

			// åŸ·è¡Œ DNS è¨˜éŒ„æ›´æ–°æª¢æŸ¥
			if err := d.UpdateDNSRecords(); err != nil {
				fmt.Printf("âŒ ç¬¬ %d æ¬¡æª¢æŸ¥å¤±æ•—: %v\n", checkCounter, err)
			}

		case <-d.stopChan:
			fmt.Println("\nğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡è™Ÿï¼Œæ­£åœ¨åœæ­¢ DDNS æœå‹™...")
			d.webhook.SendInfo("DDNS æœå‹™å·²åœæ­¢")
			return nil
		}
	}
}

func (d *DDNSService) Stop() {
	fmt.Println("\nâ¹ï¸  æ­£åœ¨åœæ­¢æœå‹™...")
	d.stopChan <- true
}

// ç²å–æœå‹™ç‹€æ…‹ä¿¡æ¯
func (d *DDNSService) GetStatus() map[string]interface{} {
	status := make(map[string]interface{})
	status["current_ip"] = d.currentIP
	status["dns_records"] = d.dnsIPs
	status["last_check"] = d.lastCheck.Format("2006-01-02 15:04:05")
	status["next_check"] = d.nextCheck.Format("2006-01-02 15:04:05")
	status["monitored_records"] = len(d.config.DNSRecords)
	status["check_interval"] = d.config.Global.CheckInterval

	// è¨ˆç®—å‰©é¤˜æ™‚é–“
	timeUntilNext := time.Until(d.nextCheck)
	status["seconds_until_next"] = int(timeUntilNext.Seconds())

	return status
}

// æ‰‹å‹•è§¸ç™¼ç«‹å³æª¢æŸ¥
func (d *DDNSService) ForceUpdate() error {
	fmt.Println("ğŸ”§ æ‰‹å‹•è§¸ç™¼ç«‹å³æª¢æŸ¥...")
	return d.UpdateDNSRecords()
}

// æª¢æŸ¥ç‰¹å®šè¨˜éŒ„çš„ç‹€æ…‹
func (d *DDNSService) CheckRecordStatus(recordName string) (map[string]string, error) {
	result := make(map[string]string)

	// æŸ¥æ‰¾è¨˜éŒ„é…ç½®
	var recordConfig *config.DNSRecord
	for _, record := range d.config.DNSRecords {
		if record.Name == recordName {
			recordConfig = &record
			break
		}
	}

	if recordConfig == nil {
		return nil, fmt.Errorf("æœªæ‰¾åˆ°è¨˜éŒ„: %s", recordName)
	}

	// ç²å–ç•¶å‰å…¬å…± IP
	currentIP, err := d.GetCurrentIP()
	if err != nil {
		return nil, err
	}
	result["current_ip"] = currentIP

	// ç²å– DNS è¨˜éŒ„ IP
	dnsIP, err := d.cfClient.GetDNSRecordIP(recordName, recordConfig.Type)
	if err != nil {
		return nil, err
	}
	result["dns_ip"] = dnsIP

	// æª¢æŸ¥åŒæ­¥ç‹€æ…‹
	if currentIP == dnsIP {
		result["status"] = "åŒæ­¥"
		result["sync_status"] = "âœ…"
	} else {
		result["status"] = "ä¸åŒæ­¥"
		result["sync_status"] = "âš ï¸"
	}

	result["record_name"] = recordName
	result["record_type"] = recordConfig.Type
	result["proxied"] = fmt.Sprintf("%v", recordConfig.Proxied)
	result["ttl"] = fmt.Sprintf("%d", recordConfig.TTL)
	result["next_check"] = d.nextCheck.Format("15:04:05")

	return result, nil
}
